#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef int (*funcp) ();

void parseRet( unsigned char *codeArray, int *codeCount, char *cmd, char* addrFill, int *addrFillCount )
{
	char word[20]; //, ebpIncr;
	int * p;

	sscanf(cmd, " %*s %s", word);
	if(word[0] == '$')
	{
		if(atoi(&word[1]) != 0)
			return;

		codeArray[(*codeCount)++]=0xb8;

		sscanf(cmd, " %*s %*s %s", word);
		if(word[0] == '$') {
			p=(int*)&codeArray[*codeCount];
			*p = atoi(&word[1]);
			*codeCount += 4;
		} else {
			// retorno garantido ($0) de variavel
		}
		
		codeArray[(*codeCount)++]=0xeb;
		codeArray[(*codeCount)++]=0x00;
		addrFill[ (*addrFillCount) ] = (*codeCount) - 1;
		(*addrFillCount)++;
		
	} else {
		// retorno condicional
	}
}


void parseAssign( unsigned char *codeArray, int *codeCount ) {
	int *p;
	char assigned[10], comp[2][20], ebpIncr, operand;

	if(sscanf(cmd, " %s %*s %s %c %s", assigned, comp[0], operand, comp[1]) != 4) return;
	if(comp[0] == '$') {
		codeArray[(*codeCount)++]=0xb9;

		p=(int*)&codeArray[*codeCount];
		*p = atoi(&word[1]);
		*codeCount += 4;
	} else {
		codeArray[(*codeCount)++]=0x8b;
		codeArray[(*codeCount)++]=0x4d;
		if(comp[0] == 'v')
			ebpIncr = (-4 * (atoi(&comp[1])+1) );
		else
			ebpIncr = ( 4 * atoi(&comp[1])) + 8

		codeArray[(*codeCount)++] = (unsigned char)ebpIncr;
	}

	switch(operand) {
		case '+':
			
		
	
}


void parseFunction(FILE *f, unsigned char * codeArray, int *codeCount)
{
	char cmd[100], word[20], addrFill[20];
	int i, addrFillCount = 0;

	// Function init
	codeArray[(*codeCount)++]=0x55;
	codeArray[(*codeCount)++]=0x89;
	codeArray[(*codeCount)++]=0xe5;
	codeArray[(*codeCount)++]=0x83;
	codeArray[(*codeCount)++]=0xc4;
	codeArray[(*codeCount)++]=0x28;
	//

	while( fscanf(f, " %[^\n]", cmd) == 1 && strcmp(cmd, "end") != 0)
	{
		
		// parse ret
		if( strncmp(cmd, "ret", 3) == 0 ) {
			parseRet( codeArray, codeCount, cmd, addrFill, &addrFillCount );
		}
		//

		// parse assignment
		else if( sscanf(cmd, " %*s %s", word) == 1 && word[0] == '=' ) {
			parseAssign( codeArray, codeCount )
		}
		//

		//
		else {
			printf("--- COMANDO IGNORADO ---\n--> %s\n\n", cmd);
		}

	}
	
	for(i = 0; i < addrFillCount; i++) {
		codeArray[addrFill[i]] = (unsigned char)( (*codeCount) - addrFill[i] - 1);
	}

	// Function end
	codeArray[(*codeCount)++]=0x89;
	codeArray[(*codeCount)++]=0xec;
	codeArray[(*codeCount)++]=0x5d;
	codeArray[(*codeCount)++]=0xc3;
	//
}

void gera(FILE *f, void **code, funcp *entry)
{
	//unsigned char codeArray[200];
	unsigned char* functions[10], *codeArray;
	int codeCount = 0, fnCount = 0;
	char word[20];

	rewind( f );

	codeArray = (unsigned char *)malloc(200);

	while( fscanf(f, " %s", word) == 1 && strcmp(word, "function") == 0)
	{
		functions[fnCount++] = &codeArray[codeCount];
		parseFunction(f, codeArray, &codeCount);
	}

//	*code = malloc(codeCount+1);
//	memcpy( *code, codeArray, codeCount+1);
	*code = codeArray;
	*entry = (funcp)functions[fnCount-1];

	//*entry = (void *)functions[fnCount-1] - (void *)codeArray + (*code);
}

int main(void) {
	FILE *f;
	void * code;
	funcp fn;

	f = fopen("code.ltd","r");
	gera(f, &code, &fn);
	printf( "\nresultado: %d\n", (*fn)());

	return 0;
}
